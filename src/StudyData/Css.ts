export const cssMethod = '<h2>css가 어려운 이유</h2><ul><li>명세가 HTML처럼 하나의 문서로 개발되는게 아닌 모듈 기준으로 나뉘어서 개발된다.</li><li>표준 명세를 찾아다니는 것도 어렵고, 이해하기도 어렵다</li><li>시행착오에 의존하고 요행을 바라기 때문<strong>(문제는 해결했지만 원인을 모르게 된다.)</strong></li><li>문법 구조만 보고 선택자와 속성과 값으로 구성되어있기때문에 쉽게 생각하기 쉽지만, 명세를 보다보면 복잡하게 구성되어 있다.</li></ul><p><img src="https://raw.githubusercontent.com/jlkim909/githubPractice/main/cssMethod1.png"></p><h2>CSS를 어떻게 공부해야 하는가?</h2><ul><li>바둑처럼 배우면 된다</li><li>출력 결과를 분석하고 실수를 복기 [css 명세]</li><li>내가 어떻게 해서 이 문제를 해결했는지 정확하게 알기 위해서는 css 명세를 봐야한다.</li></ul><p>명세 중에서도 CSS의 값을 작성하는 방법을 아는게 가장 중요하다</p><p>-&gt; 값 정의 구문이라고 부른다</p><h2>Value definition syntax(값 정의 구문)</h2><ul><li>명세 중에서도 CSS의 값을 작성하는 방법을 아는게 가장 중요하다</li><li>CSS 속성의 유효한 값과 순서 작성하는 방법</li></ul><p><img src="https://raw.githubusercontent.com/jlkim909/githubPractice/main/cssMethod2.png"></p><ul><li>값 명세를 보면 난해하게 적혀있는 경우가 있기 때문에 해석을 잘 해야한다.</li><li>속성값을 적는 순서, 혹은 횟수 등을 값 명세에서 확인할 수 있다.</li></ul><p><br></p><p><strong>Value Types</strong></p><p><strong>&gt; keywords</strong></p><ul><li>이미 정해진 예약된 단어. 값에 해당</li><li>Ex) initial, inherit, unset, block, inline, inline-block, auto, disc, collapse, separate...</li><li>따옴표 없이 사용. 대소문자 구별 안 함</li></ul><p><strong>&gt; &lt;*&gt; 기본 자료형</strong></p><p><img src="https://raw.githubusercontent.com/jlkim909/githubPractice/main/cssMethod3.png"></p><ul><li>&lt;따옴표&gt;가 없으면 <u>기본 자료형</u>, 있으면 그 <u>이름의 속성의 값을 참조</u></li><li>Ex)</li><li>&lt;absolute-size&gt; 기본 자료형 [xx-small | x-small .... | x-large | xx-large]</li><li>&lt;"grid-template"&gt; : grid-template 속성의 value 형식을 참조. 보통 단축 속성 값 정의 구문에 등장</li></ul><p><strong>Combinators / Multipliers</strong></p><p><img src="https://raw.githubusercontent.com/jlkim909/githubPractice/main/cssMethod4.png"></p><p>&gt; 결합 기호(빨간색)</p><ul><li>[1] : 공백(and) : 둘 이상의 값이 필수. 순서 유지 필수</li><li>[2] : &amp;&amp;(and) : 둘 이상 값이 필수. 순서 변경 가능</li><li>[3] : ||(or) : 두 값 중 하나 이상 필수. 순서 변경 가능</li><li>[4] : |(only) : 두 값 중 하나만</li><li>[5] : [](group) : 그룹</li><li>1~4는 우선 순위. 우선 순위가 높은 기호를 먼저 해석해야 한다.</li></ul><p>&gt; 증가 기호(파란색)</p><ul><li>* : 횟수 제한 없음. 0~무한대 가능</li><li>+ : 1회 이상</li><li>? : 0회 또는 1회</li><li>{A} : 정확히 A회</li><li>{A,B} : 최소 A회, 최대 B회</li><li>{A,} : 최소 A회 필요, 최대값 무제한</li><li># : 1회 이상. 값을 콤마(,)로 분리. 횟수 제한 가능. 예)&lt;length&gt;#{1,4}</li></ul><p>??? : + 와 #이 다른게 있나.</p><ul><li>[]! : 그룹에서 적어도 1회 이상.</li></ul>'

export const cssNeon = '<h1>네온사인</h1><p><br></p><p><br></p><h2>빛번짐 효과를 내는 속성</h2><ul><li><strong>box-shadow</strong></li><li><strong>filter: drop-shadow() ( feat. blur )</strong></li></ul><p>filter : blur(&lt;px&gt;)를 사용하면 내가 원하는 요소의 바깥쪽만 blur처리가&nbsp;되는 것이 아닌 해당 요소&nbsp;모든것이 blur처리가 되어 글자,&nbsp;아이콘까지도 흐릿하게 보이게 된다.</p><p class="ql-align-center"><img src="https://blog.kakaocdn.net/dn/cmM40R/btrsc0UtiJ1/lvI7fKBkzBvuqkMKfudVxK/img.png"></p><p class="ql-align-center"><span class="ql-size-small">왼쪽은 filter:blur(3px) 적용</span></p><p class="ql-align-center"><br></p><h2>box-shadow와 drop-shadow의 차이</h2><p><strong>box-shadow</strong>가&nbsp;<strong>영역의 shadow</strong>를 설정하는 것이기 때문에&nbsp;<strong>네모난 영역의 그림자</strong>를 생성하는 것이라면,</p><p><strong>drop-shadow</strong>는&nbsp;<strong>실제 존재하는 선을 인식</strong>하여 그림자를 생성시켜 준다.</p><p><br></p><p><strong>box-Shadow 파라미터(순서대로 적용)</strong></p><p><br></p><ul><li><code><strong>inset(default)</strong></code>: 요소가 공중에 떠있는 것처럼 밖에 드리우는 그림자가 됩니다.&nbsp;<code>inset</code>&nbsp;키워드가 존재하면 요소가 움푹 들어간 것처럼 그림자가 요소의 테두리 안, 배경색 위, 내부 콘텐츠 밑에 그려집니다.</li><li><code><strong>&lt;offset-x&gt;</strong></code><strong>&nbsp;</strong><code><strong>&lt;offset-y&gt; (&lt;length&gt;)</strong></code>: <strong>x</strong>는 수평 거리를 의미, <strong>y</strong>는 수직 거리를 의미. 음수값을 사용할 수 있다. 두 값이 모두&nbsp;<code>0</code>이면 그림자가 요소 바로 뒤쪽에 위치하며,&nbsp;<code>&lt;blur-radius&gt;</code>&nbsp;또는&nbsp;<code>&lt;spread-radius&gt;</code>가 존재하면 흐려지는 효과를 볼 수 있습니다.</li><li><code><strong>&lt;blur-radius&gt; :</strong></code>크면 클 수록 그림자 테두리가 흐려지므로 크기는 더 커지고 색은 더 밝아지고, 음수 사용 불가. 값을 설정하지 않으면&nbsp;<code>0</code>이 되어 테두리가 선명해진다.</li><li><code><strong>&lt;spread-radius&gt;</strong></code>: 양수 값은 그림자가 더 커지고 확산하며, 음수 값은 그림자가 줄어듭니다. 기본값은&nbsp;<code>0</code>입니다.</li><li><code><strong>&lt;color&gt;</strong></code></li></ul><p>여러개의 box-shadow를 사용하면 다음과 같은 효과를 볼 수 있다.</p><ol><li><span style="background-color: rgb(40, 44, 52); color: rgb(171, 178, 191);"> </span><span style="color: rgb(152, 195, 121);" class="hljs-attribute">box-shadow</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">: </span><span style="color: rgb(209, 154, 102);" class="hljs-number">5px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">5px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">#289fed</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">, </span><span style="color: rgb(209, 154, 102);" class="hljs-number">10px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">10px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">#5fb8ff</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">, </span><span style="color: rgb(209, 154, 102);" class="hljs-number">15px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">15px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">#a1d8ff</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">, </span><span style="color: rgb(209, 154, 102);" class="hljs-number">20px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">20px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">#cae6ff</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">,</span></li><li><span style="color: rgb(209, 154, 102);" class="hljs-number">25px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">25px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">#e1eeff</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">, </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(209, 154, 102);" class="hljs-number">5px</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);"> </span><span style="color: rgb(230, 192, 123);" class="hljs-built_in">rgba</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">(</span><span style="color: rgb(209, 154, 102);" class="hljs-number">0</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">, </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">, </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">, </span><span style="color: rgb(209, 154, 102);" class="hljs-number">0</span><span style="color: rgb(171, 178, 191); background-color: rgb(40, 44, 52);">);</span></li></ol><p><img src="https://blog.kakaocdn.net/dn/94M3q/btrshzJn8MA/IttW7CHFkx0vN7uQie3fs0/img.png"></p><p><strong>filter:drop-shadow()</strong></p><ul><li>box-shadow와 유사하지만, spread 속성이 없다.</li><li>여러개의 drop-shadow를 사용하면 색감 대비를 더 명확하게 낼 수 있다.</li></ul><p><img src="https://blog.kakaocdn.net/dn/cHdHl6/btrscPrOyT2/4ZiRZYRvdibWoKZyKwvZ21/img.png"></p><p><br></p>'

export const cssinitial = '<h2>CSS의 초기화</h2><p><br></p><p><strong>Reset by [class]:where()</strong> : 삼성 인터넷 브라우저에서 지원하지 않음</p><ol><li><span style="color: rgb(106, 153, 85);">/* Reset body */</span></li><li>:where(<span style="color: rgb(215, 186, 125);">body</span>) {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">margin</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">overflow-wrap</span>: <span style="color: rgb(206, 145, 120);">break-word</span>;</li><li>}</li><li><br></li><li><span style="color: rgb(106, 153, 85);">/* Do not break Korean words 한국어,중국어,일본어를 단어 중간에서 강제로 줄바꿈되는걸 막아준다.*/</span></li><li>:where(<span style="color: rgb(215, 186, 125);">:lang</span>(ko)) { <span style="color: rgb(156, 220, 254);">word-break</span>: <span style="color: rgb(206, 145, 120);">keep-all</span>; }</li><li><br></li><li><span style="color: rgb(106, 153, 85);">/* Reset img 이미지는 웹페이지보다 클 수 있기 때문에  적절하게 최대 너비를 제안시켜주도록 한다*/</span></li><li>:where(<span style="color: rgb(215, 186, 125);">img</span>) {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">max-width</span>: <span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(206, 145, 120);">auto</span>;</li><li>}</li><li><br></li><li><span style="color: rgb(106, 153, 85);">/* CSS Reset by [class] */</span></li><li>:where([<span style="color: rgb(156, 220, 254);">class</span>]) {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">box-sizing</span>: <span style="color: rgb(206, 145, 120);">border-box</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">margin</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">padding</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>}</li><li>:where([<span style="color: rgb(156, 220, 254);">class</span>])<span style="color: rgb(215, 186, 125);">::before</span>,</li><li>:where([<span style="color: rgb(156, 220, 254);">class</span>])<span style="color: rgb(215, 186, 125);">::after</span> {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">box-sizing</span>: <span style="color: rgb(206, 145, 120);">border-box</span>;</li><li>}</li><li>:where(<span style="color: rgb(215, 186, 125);">ol</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">ul</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">li</span>[<span style="color: rgb(156, 220, 254);">class</span>]) { <span style="color: rgb(156, 220, 254);">list-style</span>: <span style="color: rgb(206, 145, 120);">none</span>; }</li><li>:where(<span style="color: rgb(215, 186, 125);">button</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">fieldset</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">iframe</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">input</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">select</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">textarea</span>[<span style="color: rgb(156, 220, 254);">class</span>]) { <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">0</span>; }</li><li>:where(<span style="color: rgb(215, 186, 125);">button</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">dialog</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">input</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">mark</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">meter</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">progress</span>[<span style="color: rgb(156, 220, 254);">class</span>]) { <span style="color: rgb(156, 220, 254);">background-color</span>: <span style="color: rgb(206, 145, 120);">transparent</span>; }</li><li>:where(<span style="color: rgb(215, 186, 125);">table</span>[<span style="color: rgb(156, 220, 254);">class</span>]) {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">border-spacing</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">border-collapse</span>: <span style="color: rgb(206, 145, 120);">collapse</span>;</li><li>}</li><li><br></li><li>:where(<span style="color: rgb(215, 186, 125);">button</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">input</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">meter</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">progress</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">select</span>[<span style="color: rgb(156, 220, 254);">class</span>], <span style="color: rgb(215, 186, 125);">textarea</span>[<span style="color: rgb(156, 220, 254);">class</span>]) {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">-webkit-appearance</span>: <span style="color: rgb(206, 145, 120);">none</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">appearance</span>: <span style="color: rgb(206, 145, 120);">none</span>;</li><li>}</li></ol><p><br></p><p><strong>Reset by [class]</strong></p><ol><li><span style="color: rgb(106, 153, 85);">/* Reset body */</span></li><li><span style="color: rgb(215, 186, 125);">body</span> {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">margin</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">overflow-wrap</span>: <span style="color: rgb(206, 145, 120);">break-word</span>;</li><li>}</li><li><br></li><li><span style="color: rgb(106, 153, 85);">/* Do not break Korean words */</span></li><li><span style="color: rgb(215, 186, 125);">:lang</span>(ko) { <span style="color: rgb(156, 220, 254);">word-break</span>: <span style="color: rgb(206, 145, 120);">keep-all</span>; }</li><li><br></li><li><span style="color: rgb(106, 153, 85);">/* Reset img */</span></li><li><span style="color: rgb(215, 186, 125);">img</span> {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">max-width</span>: <span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(206, 145, 120);">auto</span>;</li><li>}</li><li><br></li><li><span style="color: rgb(106, 153, 85);">/* CSS Reset by [class] */</span></li><li>[<span style="color: rgb(156, 220, 254);">class</span>] {</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">margin</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">padding</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">box-sizing</span>: <span style="color: rgb(206, 145, 120);">border-box</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">list-style</span>: <span style="color: rgb(206, 145, 120);">none</span>; <span style="color: rgb(106, 153, 85);">/* ol, ul */</span></li><li>&nbsp; <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">0</span>; <span style="color: rgb(106, 153, 85);">/* button, fieldset, iframe, input, select, table, textarea */</span></li><li>&nbsp; <span style="color: rgb(156, 220, 254);">background-color</span>: <span style="color: rgb(206, 145, 120);">transparent</span>; <span style="color: rgb(106, 153, 85);">/* button, dialog, input, mark, meter, progress */</span></li><li>&nbsp; <span style="color: rgb(156, 220, 254);">border-collapse</span>: <span style="color: rgb(206, 145, 120);">collapse</span>; <span style="color: rgb(106, 153, 85);">/* table */</span></li><li>&nbsp; <span style="color: rgb(156, 220, 254);">border-spacing</span>: <span style="color: rgb(181, 206, 168);">0</span>; <span style="color: rgb(106, 153, 85);">/* table */</span></li><li>&nbsp; <span style="color: rgb(156, 220, 254);">-webkit-appearance</span>: <span style="color: rgb(206, 145, 120);">none</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">appearance</span>: <span style="color: rgb(206, 145, 120);">none</span>; <span style="color: rgb(106, 153, 85);">/* button, input, meter, progress, select, textarea */</span></li><li>}</li><li>[<span style="color: rgb(156, 220, 254);">class</span>]<span style="color: rgb(215, 186, 125);">::before</span>,</li><li>[<span style="color: rgb(156, 220, 254);">class</span>]<span style="color: rgb(215, 186, 125);">::after</span> { <span style="color: rgb(156, 220, 254);">box-sizing</span>: <span style="color: rgb(206, 145, 120);">border-box</span>; }</li></ol><p><br></p><p><strong>css 리셋</strong></p><ul><li>리셋이 꼭 필요한가.</li><li>대부분의 css 리셋 스타일은 덮어쓰게 되고 사용하지 않게 된다.</li></ul><p><strong>*(Universal Selector)</strong></p><ul><li>모든 HTML 요소를 전부 선택하는 선택자</li><li>처음에는 편할지 모르나 결국 스타일을 오버라이드 하거나 불필요한 스타일을 모든요소에 적용되거나 하기때문에 지양하도록 한다.</li></ul><p><strong>Find unused CSS (사용하지 않는 CSS) 확인하기</strong></p><ul><li>chrome : 개발자 도구 -&gt; covarage 탭</li><li>Mac : Cmd + Shift + P + (coverage)</li><li>Win : Ctrl + Shift + P + (coverage)</li></ul><p><br></p><p>CSS 리셋에서 기본 HTML 요소의 스타일을 개발자가 임의로 많이 재정의하는 것을 조심스럽게 생각해야한다.</p><ul><li>가급적이면 "class"라는 속성이 들어있는 요소만 찾아서 스타일을 리셋 시켜주고, 사용자가 위지윅 에디터를 통해서 작성한 스타일이나 태그는 가능한 유지시켜 주는 방법을 선호</li><li>유용한 이유 : 사용자들이 위지윅 에디터에 글을 작성을 할 때, 다른 글을 그대로 복사해서 붙여넣기 하는 경우가 있다. 이럴 때 기존 복사해서 가져다 놓은 스타일이 가능하면 이 웹페이지의 스타일들과 충돌하지 않아야 깨지지 않는다. HTML에 리셋 스타일을 적용하면 깨지는 경우가 발생할 수 있다.</li><li>문제점 : class가 들어있는 모든 요소를 초기화 한다는 점. 예를 들어 모든 요소가 list-style이나 border 속성을 가지고 있지 않지만, 초기화 시키게 된다.</li></ul><p><strong>where 가상 클래스 선택자를 사용</strong>하는 방법 </p><ul><li>특징 : 괄호 안에 선택자를 넣어서 사용할 수 있다.</li><li>선택자 정수 , 선택자 특이성을 증가시키지 않는다.</li><li>유사한 가상 클래스로 is가 있지만 is는 선택자 특성을 증가시킨다.</li><li>문제 : 삼성 인터넷 브라우저가 지원을 하지 않고 있다.</li></ul><p><br></p>'

export const namingBEM ='<h1>BEM</h1><p>웹은 덩어리, 구성요소, 변형의 반복으로 이루어져 있다.</p><p> 네이밍 기법</p><ul><li>css를 관리하기 어려운 포인트 중 하나로 선택자의 이름을 정하고 선택자의 중첩 규칙을 정해서 관리하는 부분이다.</li><li>대규모 프로젝트에 필요</li><li>현존하는 웹 개발자들이 가장 많이 사용하고, 높은 만족도를 가지고 있는 네이밍 기법이다.</li></ul><p><br></p><p><strong>작명 규칙을 잘못 관리한 사례</strong></p><ul><li>의미를 알 수 없는 작명 .bx, .cnt, .mt ...</li><li>전역 공간을 선점한 흔한 이름 .content, .button, .top ...</li></ul><p><strong>선택 규칙을 잘못 관리한 사례</strong></p><ul><li>a{text-decoration:none;} -&gt; 모든 a 요소의 밑줄을 없애버림</li><li>local.css 파일</li><li>.module a{text-decoratioin:underline;}</li><li>#special.module a{text-decoration :none;}</li><li>...</li><li>모든 a요소의 밑줄을 없애고, .module에서는 다시 밑줄을 생성하고, 다시 다른 곳에서는 없애는 등, 불필요하게 작성된 코드가 있음</li><li>선택자의 깊이도 높아지고, 선택자의 특이성 역시 높아지게 되어 결국 덮어쓰기 위해서는 더 길고 구체적인 선택자가 필요하게 되어 관리하기 어렵게 된다.</li></ul><h2><strong>CSS selector specificity (선택자 우선순위 규칙)</strong></h2><ul><li>[1] id(0) 선택자</li><li>[2] class,[attr], :class(0) 선택자 </li><li>[3] type, ::element(0) 선택자 </li><li>ex)</li></ul><p class="ql-indent-3">a -&gt; 001</p><p class="ql-indent-3">.a -&gt; 010</p><p class="ql-indent-3">#a -&gt; 100</p><p class="ql-indent-3">#a a -&gt; 101</p><p class="ql-indent-3">#a.a a -&gt; 111</p><p class="ql-indent-3">#a#b[href]::before -&gt; 211 </p><ul><li>css 선택자의 우선순위를 높여 놓으면 덮어쓰기 위해서는 더 높은 선택자가 필요하게 된다.</li><li>특이성 점수를 020보다 낮게 유지하는 것이 css선택자를 관리하기 좋다.</li><li>cssstats.com 으로 css 선택자 점수를 측정할 수 있다.</li></ul><p><br></p><p><strong>BEM : 명명 규칙</strong></p><ul><li>Block : 재사용 가능한 독립적인 블록</li><li>Element : 블록을 구성하는 종속적인 하위 요소</li><li>Modifier : 블록 또는 요소의 변형(모양, 상태, 동작)</li></ul><p><br></p><ul><li>두 개의 언더바(__*)는 하위 요소를 의미</li><li>두 개의 하이픈(--*)은 상태 변형을 의미</li><li>하나의 이름에 요소, 변형은 각 한 번만 허용</li><li>선택자 특이성이 높아지는 중첩 구조, 타입 선택자는 안티 패턴으로 구분</li></ul><p><strong>BEM : 특징(엄격한 의미론)</strong></p><ul><li>의미론적 클래스 선택자 작명 규칙</li><li>다른 형식의 선택자 사용을 제한(--, __ 만 사용가능)</li><li>전역에서 유일한 이름 권장</li><li>낮은 선택자 특이성 유지</li><li>HTML/CSS 연결이 느슨. 병렬 개발 가능</li></ul><p><strong>BEM : 응용 예제</strong></p><ul><li>이름 공간을 위한 접두어 사용 추천</li><li>.Ex) lzModal , .lzModal__title .....</li><li>다른 라이브러리와 공존 가능</li></ul><p><br></p><p><strong>Atomic / Uility First CSS</strong></p><p>tailwind.. emotion..</p><ul><li>라이브러리 타입으로 빠른 스타일 구축 가능</li><li>다른 방법론과 함께 사용 가능</li><li>스타일 관점의 작명. 의미론을 사용하지 않음</li><li>HTML 코드에 스타일이 강하게 연결됨</li><li>HTML/CSS 병렬 개발 불가능. </li><li>소규모 팀 또는 단일 엔지니어 개발에 적합</li><li>나온지 얼마 안되서 사용자는 많지 않지만, 만족도는 높은편이다.</li></ul><p><br></p>'
export const cssDisplay ='<h1>Display</h1><blockquote>inline, block, inline-block, none, flow-root, flex, grid, contents</blockquote><p><strong>Changed Display</strong></p><ul><li>포지션 속성을 absolute 또는 fixed 처리하거나 float 속성의 값을 left, right로 설정하면 display 속성은 block으로 바뀌게 된다.</li><li><span style="background-color: rgb(204, 232, 204);">position(absolute, fixd), float 속성을 사용할 경우 display 속성을 사용할 필요가 없다.</span></li></ul><h2>inline</h2><ul><li>흐름 방향 : 수평</li><li>너비와 높이, <span style="background-color: rgb(204, 232, 204);">수직 마진 적용 불가</span></li><li>수평 마진, 수평 패딩 적용 가능</li><li>수평 패딩은 적용 가능하나 패딩이 다른 요소를 밀어내지는 못한다.(적용 되지만, 마치 적용되지 않은것처럼 보인다.)</li></ul><h2>block</h2><ul><li>흐름 방향 : 수직</li><li>너비, 높이, 수평마진, 수직마진, 수평패딩, 수직패딩 모두 다 적용 가능</li><li><span style="background-color: rgb(204, 232, 204);">수직 마진을 적용할 경우 중첩이 발생한다.</span></li><li><span style="background-color: rgb(204, 232, 204);">자식요소와 부모요소의 마진이 병합 됨</span></li></ul><p><br></p><h2>inline-block</h2><ul><li>block의 특징과 inline의 특징을 모두 가지고 있다.</li><li>흐름 방향 : 수평</li><li>너비, 높이, 수평마진, 수직마진, 수평패딩, 수직패딩 모두 다 적용 가능</li><li><span style="background-color: rgb(204, 232, 204);">수직 마진을 적용할 경우 중첩이 되지 않는다.</span></li><li>line-height 속성의 영향을 받는다.</li></ul><p><br></p><h2>none</h2><ul><li>어떤 장치도 표시하거나 접근할 수 없음.</li><li>화면, 인쇄, 보조공학기기, 마우스 키보드 등 접근할 수 없음.</li><li>hidden 속성을 주는 것도 같은 효과이다.</li></ul><p><br></p><h2>flow-root</h2><ul><li>block 컨테이너가 된다.</li><li>포함 콘텐츠는 새 블록 형식 문맥(block formatting context)이 된다.</li><li>포함한 float요소는 컨테이너 끝에서 clear 된다.</li><li>부모-자식 요소의 수직 마진을 병합하지 않는다.(독립적으로 적용 됨)</li><li><span style="background-color: rgb(204, 232, 204);">float을 사용하거나 수진 마진을 병합하지 않는 것을 의도하는 맥락에서 사용</span></li></ul><p><strong>[추가] flow-root를 사용해서 float을 해제하는 기법</strong></p><p>보통 floot을 사용하면 부모 컨테이너의 높이를 벗어나 자식이 붕 떠버리는 현상이 발생하는데, flow-root를 사용하면 float된 영역은 일반적인 흐름에서 벗어나지만 float된 영역에 높이를 부모 컨테이너가 감지해서 반영한다.</p><p>-&gt; 이걸 float을 해제한다고 부름</p><h2>flex</h2><ul><li>flex 컨테이너 박스를 생성한다.</li><li>flex 형식 문맥을 설정한다.</li><li>포함 아이템(자식요소)을 1차원 기반으로 배치한다.(자식 요소가 flex item이 된다.)</li><li><span style="background-color: rgb(204, 232, 204);">특징 : 격자에 구애를 받지 않음</span></li></ul><h2>grid</h2><ul><li>grid 컨테이너 박스를 생성한다.</li><li>grid 형식 문맥을 설정한다.</li><li>포함 아이템을 2차원 기반으로 배치한다.</li><li>-&gt; 마치 표와 비슷하게 컨테이너 안에 트랙을 그리고 2차원 격자를 그린 다음에 트랙 안에 내용 아이템들을 배치하는 특징을 가지고 있다.</li><li><span style="background-color: rgb(204, 232, 204);">특징 : 셀의 병합 가능</span></li></ul>'
export const cssPosition = '<h1>Position</h1><p><br></p><h2>static</h2><ul><li>배치 기준이 없음</li><li>흐름에 따라 배치</li><li>left, right, top, bottom, z-index 속성 사용 불가</li><li>주변의 형제노드들과의 관계에 의해서 자리가 결정된다. -&gt; 누가 밀면 밀림 , 차곡차곡 배치</li></ul><h2>relative</h2><ul><li>박스의 현재 위치가 배치의 기준</li><li>배치를 변경할 때 <span style="background-color: rgb(204, 232, 204);">다른 박스의 흐름을 깨지 않음</span></li><li>자식 또는 자손 요소의 absolute 배치 기준이 됨.</li><li><span style="background-color: rgb(250, 204, 204);">inset : left, right, top, bottom 속성을 한번에 지정할 수 있는 속성</span></li></ul><h2>absolute</h2><ul><li>일반적인 흐름에서 완전히 이탈</li><li>부모, 형제의 크기나 위치에 전혀 영향을 미치지 않음.(다른 층에 떠있다고 생각하면 된다.) -&gt; <span style="background-color: rgb(204, 232, 204);">다른 요소와 겹치는 효과를 연출하려고 할 때 사용</span></li><li>조상 박스가 relative, absolute, fixed, <span style="background-color: rgb(250, 204, 204);">transform 일 때</span>, 조상 기준으로 배치</li></ul><h2>fixed</h2><ul><li>뷰포트가 배치 기준</li><li><span style="background-color: rgb(204, 232, 204);">조상 요소에 transform 속성이 있으면 transform 속성이 있는 요소가 배치 기준이 된다.</span></li></ul><h2>sticky</h2><ul><li>스크롤 포트가 배치 기준(스크롤 포트라고 불리는 스크롤 바가 있는 박스가 필요)</li><li>부모 요소가 스크롤 포트에 보이는 동안 스크롤 포트기준으로 고정</li><li>부모 요소가 스크롤 밖으로 이탈하면 고정을 멈춤</li><li><span style="background-color: rgb(204, 232, 204);">세가지 조건이 필요</span></li><li>[1] 스크롤 바(스크롤 포)가 있는 박스가 하나 필요</li><li>[2] 그 안에 자기자신이 있어야 한다</li><li>[3] 스크롤 포트를 감싸는 부모 요소가 하나 더 필요하다.</li></ul><p><strong>z-index</strong></p><ul><li>z-index는 절대값이 아닌, 부모 요소에 종속 된다<span style="background-color: rgb(204, 232, 204);">.(부모 요소보다 높은 z-index를 가질 수 없다.)</span></li></ul>'
export const cssPaddingMargin ='<h1>Margin &amp; Padding</h1><p><br></p><p><strong>box-sizing 속성</strong></p><ul><li>value : content-box(default) | border-box</li><li>content-box : padding값과 border 값은 width, height 값에 포함되지 않는다.</li><li>border-box : padding값과 border 값이 포함된다.(더 많이 사용)</li></ul><p><span style="background-color: rgb(250, 204, 204);">vmax, vmin</span> : viewport에 너비 또는 높이 중에 큰 값(작은 값)을 선택해서 적용된다.</p><h2>padding</h2><ul><li>컨테이너 블럭의 너비 값을 참조해서 %값을 설정할 수 있다. -&gt; <span style="background-color: rgb(204, 232, 204);">부모 컨테이너에 해당하는 요소의 너비 값이 기준</span></li></ul><p><br></p><h2>ASECT-RATIO - 비율 유지 기법</h2><ul><li>youtube 에서 제공하는 iframe은 560px / 315px 인데, 만약 화면의 너비가 560px보다 작다면 화면이 짤리게 된다.</li><li>[1] viewport를 기준으로 설정하면 종횡비를 유지할 수 있지만, 컨테이너의 마진이나 스크롤크기를 생각해야 한다.</li><li>[2] aspect-ratio : 너비비율 / 높이비율 속성을 이용한다. 사파리, 삼성 인터넷 지원 확인이 필요하다.</li><li>[3] padding으로 종횡비 유지하기(현업에서 가장 많이 사용)</li></ul><ol><li><span style="color: rgb(215, 186, 125);">.utube</span> {</li><li>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">position</span> : <span style="color: rgb(206, 145, 120);">relative</span>;</li><li>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">padding-top</span>:<span style="color: rgb(181, 206, 168);">56.25%</span>; <span style="color: rgb(106, 153, 85);">/* 너비에 대한 높이 비율 */</span></li><li>}</li><li><br></li><li><span style="color: rgb(215, 186, 125);">.utube__iframe</span>{</li><li>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">position</span> : <span style="color: rgb(206, 145, 120);">absolute</span>;</li><li>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">width</span>:<span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">height</span>:<span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp;&nbsp;<span style="color: rgb(156, 220, 254);">top</span>:<span style="color: rgb(181, 206, 168);">0</span>;</li><li>}</li></ol><p><strong style="background-color: rgb(204, 232, 204);">종횡비 유지 유용성(필요성)</strong></p><p>[1]누적 배치 변경(CLS) 문제 해결</p><ul><li><span style="background-color: rgb(250, 204, 204);">CLS(Cumulative Layout Shift)</span> : 페이지의 전체 수명 동안 발생하는 모든 예기치 않은 레이아웃 변경에 대한 레이아웃 변경 점수의 가장 큰 버스트를 측정한 것.<u>https://web.dev/cls/</u> 참조</li></ul><p>[2] 스켈레톤 UI를 제공할 때.</p><p><span style="background-color: rgb(204, 232, 204);">[3] 이미지 지연 로딩 기법을 사용할 때</span></p><ul><li>뷰포트 밖에 이미지는 로딩시키지 않는 기법</li><li>로딩되고 렌더링 되지 않은 이미지(높이가 0)다 보니까 페이지 스크롤, 페이지의 전체 문서 길이가 아직 완전하게 계산되지 않았다는 걸 의미하고 이미지가 로딩되면서 이미지에 높이가 발생하면 계산했던 요소들이 생각한대로 렌더링되지 않을 수 있기 때문에 종횡비를 유지하여 이런 현상을 방지할 수 있다.</li></ul><p>[4] content-visibility : auto 속성을 사용할 때</p><ul><li>이미지 뿐만 아니라 다른 도움 레이아웃 요소들도 뷰포트 밖에 있을 때는 렌더링을 하지 않는 기법</li></ul><p>--&gt; 요소와 문서의 전체 높이를 일정하게 유지하는 데 필요.</p><h2>Margin</h2><ul><li>다른 박스와 테두리 사이의 여백</li><li>%value : 컨테이너 블럭의 너비 값을 참조</li></ul><p><strong>수직 마진 병합</strong></p><ul><li>인접된 형제, 부모자식사이에서만 발생</li><li>block 요소 사이에서만 발생</li><li>양수끼리, 음수끼리 만난 경우 절대값이 큰 값이 적용</li><li>양수와 음수가 만난 경우 두 값의 합</li></ul><p><strong style="background-color: rgb(250, 204, 204);">수직 마진 병합 예외</strong></p><ul><li>최상위 요소(body)의 수직 마진</li><li>부모의 diplay:flow-root</li><li>부모의 overflow:hidden | auto | scroll</li><li>부모의 padding-top/bottom 값이 0이 아닌 경우</li><li>보모의 border-top/bottom 값이 0이 아닌 경우</li><li>display : inline | inline-*</li><li>float : left | right</li></ul><p><strong>수직 마진을 병합하는 이유</strong></p><ul><li>다른 블록 요소와 수직으로 배치할 때 양쪽 수직 마진에 발생하는 과도한 간격을 상쇄하려는 목적</li></ul>'
export const cssFloat = `<h1>float</h1><p><strong>float 속성 의도 이해하기</strong></p><p>-&gt; 이미지를 배치하고 그 주변으로 텍스트가 흐르는 맥락으로 사용하는 목적이지만, 컬럼 배치를 위해 사용하는 경우가 대부분이다.</p><p>-&gt; 텍스트는 이미지 주변으로 흐르지만, 박스, block 박스 요소는 겹치게 만든다.(float을 이해하기 어렵게 만드는 특징 중 하나)</p><ul><li>플로팅 요소의 너비는 수축하고 일반적인 흐름에서 벗어난다.</li><li>인접 후행 블록 요소는 플로팅 요소와 겹치고 인라인 요소(+텍스트 노드)는 플로팅 요소 주변으로 흐른다.</li><li>clear, flow-root 속성으로 해제할 수 있다.</li><li>컬럼을 배치하는 속성이 아니다.</li><li><span style="background-color: rgb(204, 232, 204);">용도에 맞게 사용해야하고, 반드시 해제해야한다.</span></li></ul><p><strong>Float clearing</strong></p><ul><li>not clear : 플로팅된 박스는 부모 박스의 높이를 증가시키지 않고, 플로팅되지 않은 요소들의 높이만 부모에게 인지가 된다.</li><li>blank element : 부모 요소의 끝에 빈 요소를 넣고, clear:both 속성을 추가 (clear 속성은 display가 block인 경우에만 적용할 수 있음.)</li><li>부모요소에 overflow : hidden 적용 </li><li>부모요소에 display : inline-block 적용</li><li>부모 컨테이너에 <span style="background-color: rgb(204, 232, 204);">가상 요소 after 선택자를 사용</span>해서 가상의 엘리먼트를 집어넣고 그 요소를 clear 시키는 방법(가장 많이 사용 됨)</li></ul><ol><li><span style="color: rgb(215, 186, 125);">.container--after::after</span>{</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">content</span>:<span style="color: rgb(206, 145, 120);">''</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">display</span>:<span style="color: rgb(206, 145, 120);">block</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">clear</span>:<span style="color: rgb(206, 145, 120);">both</span>;</li><li>}</li></ol><ul><li>부모요소에 <span style="background-color: rgb(204, 232, 204);">display 속성을 flow-root로 바꿔준다</span>.(IE 브라우저에서는 flow-root속성을 지원하지 않음)</li></ul><p><strong>float &amp; display</strong></p><ul><li>float 요소는 보통 block이 된다.</li><li>display 속성이 없어도 width/height, 수직 margin/padding 속성을 사용할 수 있다.(따라서 보통의 경우 display 속성을 명시할 필요가 없다)</li></ul><h2>Column Layout</h2><p>-&gt; float 대신에 사용할 수 있음</p><p><strong style="background-color: rgb(250, 204, 204);">columns : &lt;"column-width"&gt; || &lt;"column-count"&gt; 속성 사용하기</strong></p><ul><li>컬럼 사이사이에는 column-rule과 column-gap이 존재한다.</li><li>보통의 경우 3개의 div에 텍스트들을 나눠 담아서 배치하지만, columns 속성을 사용하면 div나 p 엘리먼트 하나에 텍스트를 담아서 사용할 수 있다. </li><li>Demo : <u>https://t.ly/UB4A</u></li><li>break-inside : avoid - 컬럼 내용을 중간에 자르지 않도록 하는 속성</li></ul><p><strong>display : flex | grid 속성으로 제어</strong></p>`
export const cssFlex = '<h1>Flex</h1><p>-&gt; IE 브라우저를 사용하지 않으면 유용(버그가 많음)</p><p>-&gt; 박스의 크기, 방향, 순서, 정렬, 간격을 제어하는 새로운 박스 모델</p><p>-&gt; https://www.w3.org/TR/css-flexbox-1/</p><p>Flex 용어 - flex container, flex item, free space, main axis(진행 축), cross axis(교차 축)</p><p><strong>아이템 크기 자동 분배 기능</strong></p><ul><li>flex-grow/-shrink/-basis 속성이 박스의 너비가 알아서 결정되고 분배되게 해준다.</li></ul><p><strong>Free space</strong></p><ul><li>flexbox 아이템사이의 공간(margin auto로 처리 하지 않음)</li><li>플렉스 아이템이 점유하는 영역(flex-basis, width, height, padding, margin, border)을 제외하고 남은 공간</li><li>0, 양수, 음수 프리스페이스가 발생할 수 있다.</li><li>프리 스페이스는 플렉스 아이템의 팽창지수(flex-grow)와 수축 지수(flex-shrink)를 이용하여 플렉스 아이템으로 분배할 수 있다.</li></ul><p><strong>배치 순서 변경(order)</strong></p><p><strong>감싸기(flex-direction/-wrap/-flow)</strong></p><h2><strong>Flex container</strong></h2><ul><li>display 속성 값이 flex, inline-flex인 박스</li><li>내부에 흐르는 자식 콘텐츠(엘리먼트, 텍스트노드)는 자동으로 플렉스 아이템이 된다.</li><li>flex container에만 적용 가능한 속성</li><li>flex-flow: row nowrap -&gt; 흐름 방향 + 줄 바꿈</li><li>flex-direction -&gt; 흐름 방향</li><li>flex-wrap: 줄 바꿈</li></ul><p>display : flex</p><ul><li>block 박스 인것 처럼 렌더링이 된다.(수직으로 배치)</li></ul><p>display : inline-flex</p><ul><li>인라인 또는 인라인 블록 박스처럼 수평으로 배치</li></ul><h2>Flex item</h2><ul><li>플렉스 컨테이너 내부에서 흐르는 자식 박스</li><li>플렉스 박스 모델에 따라 배치된다.</li><li>flex item에만 적용 가능한 속성</li><li>flex: 팽창지수 수축지수 기준 크기</li><li>flex-grow : 팽창 지수</li><li>flex-shrink : 독립적 교차 축 정렬</li><li>flex-basis : 기준 크기</li><li>align-self : 독립적 교차 축 정렬</li><li>order : 배치 순서(상대값)</li></ul><p><strong>플렉스 아이템의 팽창과 수축</strong></p><p>flex-grow : 0(default)</p><ul><li>양의 Free space 발생 시 플렉스 아이템의 팽창을 제어</li><li>값 : &lt;number&gt;, 음수 사용 불가. 보통 0 또는 1 사용</li><li>아이템이 비율값으로 free space 값을 가져감 </li></ul><p>flex-shrink : 1(default) : </p><ul><li>음의 free space 발생 시 플렉스 아이템의 수축을 제어(음의 free space가 발생했다는 건 컨테이너보다 아이템의 면적이 넓어서 컨테이너 밖으로 나간걸 의미)</li><li>값 : &lt;number&gt;, 음수 사용 불가. 보통 0또는 1 사용</li><li>layout 밖으로 나가는건 보통 선호하는 방식이 아니기 때문에 1을 사용 하는 것을 지향</li><li>shrink:0으로 적용하면 음의 free space가 발생 하더라도 수축하지 않음</li><li>더 높은 비율을 가진 요소가 더 많이 수축</li></ul><p>flex-basis : auto(default) : </p><ul><li>flex item의 진행 방향 기본 크기를 설정함으로써 free space 초기 값에 영향을 준다.(보통 0으로 설정)</li><li>값 : content(주의-아직 구현한 브라우저가 없) | &lt;width&gt;</li><li>auto이면 flex item 박스에 적용되어 있는 width 값에 따라서 기준 값이 정해진다.</li><li>flex-grow나 flex-shrink 단축 속성을 작성하고 생략시 자동으로 0으로 설</li></ul><p>flex : 0 1 auto(default)</p><ul><li>flex item의 팽창, 수축, 기본 크기를 제어하는 단축 속성</li><li>값 : none | [&lt;"flex-grow"&gt; &lt;"flex-shrink"&gt;? || &lt;"flex-basis"&gt;] </li><li>생략한 속성의 값은 재설정(변경) 된다. -basis 생략시 0으로 설정</li><li>flex : 1 == flex : 1 1 == flex: 1 1 0 , 결국 flex : 1을 가장 많이 사용</li><li>추천하지 않는 속성(그만큼사용 빈도가 낮음)</li><li><span class="ql-size-small">flex : 0%(grow 초기 값이 0에서 1으로 변경)</span></li><li><span class="ql-size-small">flex : initial (item에 아무것도 선언하지 않았을 때의 초기 값. 초기 값과 같기 때문에 굳이 선언할 필요가 없음)</span></li><li><span class="ql-size-small">flex : none (플렉스 박스 모델을 사용하지 않기 위해 값을 덮어 쓸 필요가 있을 때 사용. == flex : 0 0 auto, flex-shrink 값이 0으로 변경된다)</span></li></ul><p><strong>플렉스 아이템의 방향과 순서</strong></p><p>flex-direction : <strong>row(default)</strong> | row-reverse | <strong>column</strong> | column-reverse</p><p>flex-wrap : nowrap(default) | wrap | wrap-reverse</p><p>flex-flow : &lt;"flex-direction"&gt; || &lt;"flex-wrap"&gt;</p><p>order : &lt;interger&gt; : 아이템의 배치 상대적 순서</p><p><br></p><h2><strong>Main axis (진행 축)</strong></h2><ul><li>flex item 배치 방향으로써 flex container에 flex-direction 속성을 적용하여 설정할 수 있다.</li><li>진행 축(flex-direction)의 초기 값은 row이며 row-reverse, column, column-reverse 값을 적용할 수 있다.(헷갈리기 때문에 추천하지 않음)</li></ul><p><strong>justify-content : 진행 축 정렬</strong></p><ul><li>값 : flex-start(default) | flex-end | <strong>center</strong> | <strong>space-between</strong> | space-around | space-evenly</li></ul><h2>Cross axis(교차 축)</h2><ul><li>flex item 배치 방향과 직각으로 교차한 방향으로써 flex container에 flex-direction 값의 직각 방향</li><li>진행 축의 방향에 따라 교차 축이 달라지기 때문에 교차 축은 행이 될 수도 있고, 열이 될 수도 있다.</li><li>align-* 속성의 기준이 되는 축이다.</li></ul><p><strong>align-items/-self/-content : 교차 축 정렬</strong></p><p><strong>-&gt; align-items</strong></p><ul><li>플렉스 아이템의 한 줄 교차축 정렬</li><li>값 flex-start | flex-end | <strong>center</strong> | baseline | stretch(default)</li><li>초기 값 : stretch (아이템을 교차 축으로 잡아 늘림)</li><li>baseline : 아이템에 들어가 있는 텍스트의 베이스 라인을 기준으로 정렬(애매해서 잘 안쓰임)</li></ul><p><strong>-&gt; align-self </strong></p><ul><li>item을 딱 하나만 잡아다가 독립적으로 정렬을 바꿔주고 싶을 때 사용</li><li>값 : auto | flex-start | flex-end | center | baseline | stretch</li><li>초기 값 : auto (컨테이너의 align-items값을 상속 받음)</li></ul><p><strong>-&gt; align-content</strong></p><ul><li>플렉스 아이템의 여러 줄 교차 축 정렬과 간격</li><li>값 : stretch(default) | <strong>center</strong> | flex-start | flex-end | space-around | <strong>space-between</strong> | space-evenly</li></ul><h2>gap</h2><ul><li>다중 컬럼, 플렉스, 그리드 아이템 사이의 간격</li><li>값 : &lt;"row-gap"&gt; &lt;"column-gap"&gt;</li><li>초기값 : normal (다중 컬럼에서 1em 그러지 않으면 0)</li><li>적용 : 컬럼/플렉스/그리드 컨테이너</li></ul><p><br></p><p><strong>보조 링크</strong></p><p>https://flexbox.help/ 실제로 변경되고 변화되는 모습을 바로바로 확인 가능</p><p>https://flexboxfroggy.com/#ko&nbsp;</p><p>https://www.flexboxdefense.com/</p><p>- flex 게임으로 연습</p><p>https://t.ly/2kOk flex속성 자료</p><p><br></p>'
export const cssGrid='<h1>Grid</h1><p>-&gt; 격자를 이용해서 내용의 크기와 위치를 제어하는 방법</p><p>-&gt; flex는 단일 축을 중심으로 배치, grid는 두 개의 축을 이용</p><p>-&gt; 특히 <span style="background-color: rgb(204, 232, 204);">셀 병합 기능을 제공.</span> 다른 수단에 비해 짧은 코드로 자유도 높은 배치를 구현</p><p><strong>단축속성</strong></p><p>Grid 용어 : grid container, grid item, grid line, grid track, grid cell, grid area, gap</p><p><strong>명시적 그리드</strong> : 트랙의 크기와 수량을 분명하게 선언한 그리드. (grid-template-* 속성으로 제어)</p><p><strong>암시적 그리드</strong> : 명시적 그리드 외부에 배치되어 흐름방향과 크기를 결정하는 그리드 (grid-auto-* 속성으로 제어)</p><h2>gird : 트랙의 수와 크기, 컨테이너에 적용</h2><p>grid-template</p><ul><li>grid-template-rows(행 트랙의 수량과 크기)</li><li>grid-template-columns(열 트랙의 수량과 크기)</li><li>grid-template-areas(셀 이름 명시)</li></ul><p>grid-auto-flow(흐름 방향과 밀집)</p><p>grid-auto-rows(암시적 행 트랙의 크기)</p><p>grid-auto-columns(암시적 열 트랙의 크기)</p><h2>grid-area : 아이템의 배치와 병합, 아이템에 적용</h2><p>grid-row</p><ul><li>grid-row-start(행 시작)</li><li>grid-row-end(행 끝)</li></ul><p>grid-column</p><ul><li>grid-column-start(열 시작)</li><li>grid-column-end(열 끝)</li></ul><h2><strong>grid container</strong></h2><p><strong>역할</strong></p><ul><li>트랙의 수량과 크기를 명시(grid-template-*)</li><li>아이템 배치 방향(grid-auto-flow)</li><li>암시적 트랙 크기(grid-auto-*)</li></ul><p><strong>grid container 생성</strong></p><ul><li>display : grid | inline-grid</li><li>그리드 컨테이너/아이템에 선언하지 않은 모든 grid-* 속성은 초기값으로 설정된다.</li><li>grid 속성으로 컨테이너의 트랙(행/열) 수와 크기를 설정하고 grid-area 속성으로 아이템의 배치와 병합을 설정하지 전까지는 그리드 컨테이너를 생성한 것만으로 특별한 효용이 없다.</li></ul><p>grid track 생성(균등)</p><ul><li>grid : " . . ."</li><li>그리드 컨테이너와 3열의 익명 트랙 단축 문법. 마침표(.)와 공백() 구분자로 익명셀을 생성. 셀 크기는 내용에 따라 자동.</li><li>트랙의 크기를 제어하지 않기 때문에 실무에서 유용하지 않은 패턴</li></ul><p><strong>grid track 생성(제어)</strong></p><ul><li>grid : 80px 1fr / 120px 1fr</li><li>2열 2행 트랙 단축 문법. 트랙의 크기와 수량을 명시적으로 제어</li><li><span style="background-color: rgb(204, 232, 204);">실무에서 가장 빈번하게 사용하는 패턴</span></li><li>명시적으로 선언하지 않은 나머지 트랙은 자동</li></ul><p><strong>grid track 생성(방향)</strong></p><ul><li>배치 방향 설정</li><li>auto-flow 값은 grid 단축 송성에서만 사용하는 값의 형태로 grid-auto-flow 속성값의 다른 표기법</li><li>슬래시(/)와 함께 교차 축 grid-template-rows/columns 값의 명시가 필수</li><li>auto-flow를 집어 넣은 곳의 방향으로 트랙이 진행한다는 걸 의미</li></ul><h2>grid item 역할</h2><ul><li>아이템의 배치와 병합, 배치 순서 결정</li></ul><p><strong>grid item 배치</strong></p><ul><li>grid-area : 2 / 3;</li><li>행 배치 시점 / 열 배치 시점 / 행 배치 종점 / 열 배치 종점 값을 선언하여 아이템의 배치 위치/크기를 결정할 수 있다.</li><li>값은 시계 반대 방향으로 순환(로컬로컬)하고 슬래시(/) 구분자로 분리한다.</li><li>생략한 값은 auto와 같다.</li></ul><p><strong>grid item 배치/병합</strong></p><ul><li>grid-area : 2 / 2 / span 3 / span 2</li><li><span style="background-color: rgb(204, 232, 204);">span 키워드와 병합할 트랙의 수량을 조합</span>하면 셀을 병합할 수 있다.</li></ul><p><strong>grid item 정렬(트랙, 복수, 단수)</strong></p><ul><li>place-content : center | start | end</li><li>트랙의 크기가 auto인 상태로 컨테이너를 가득 채우지 않는다면 트랙의 위치를 정렬할 수 있다</li><li>실무에서 많이 사용하지 않음. 알아만 둘것</li></ul><p><strong>grid dense(밀집)</strong></p><ul><li>채우지 못한 빈 영역이 있으면 흐름 방향을 거슬러 올라 트랙을 채운다.</li><li>auto-flow 값과 항상 같이 쓰임</li></ul><p>grid auto-fill/fit(동적 트랙)</p><ul><li>트랙을 채우지 못한 상황에서 트랙의 최대 크기가 auto이면 auto-fill 또는 auto-fit 방식으로 트랙의 크기와 수량을 자동으로 결정한다.</li><li>자주 사용하지 않음.</li></ul><p><strong>링크</strong></p><p>https://naradesign.github.io/css-grid-layout.html - grid 레이아웃 문법과 예제</p><p>https://cssgridgarden.com/#ko - 그리드 배치 게임</p>'
export const cssDrawIcon=`<h1>CSS로 이미지 그리기</h1><h2>삼각형 만들기</h2><ol><li><span style="color: rgb(215, 186, 125);">p::before</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">content</span>: <span style="color: rgb(206, 145, 120);">''</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">margin-right</span>: <span style="color: rgb(181, 206, 168);">8px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">40px</span> <span style="color: rgb(206, 145, 120);">solid</span> <span style="color: rgb(206, 145, 120);">transparent</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-left-color</span>: <span style="color: rgb(206, 145, 120);">red</span>;</li><li>&nbsp; }</li></ol><ul><li>before 가상 선택자를 이용하여 공백 문자열을 집어 넣음</li><li>border, border-color 속성을 사용해서 삼각형을 그림</li></ul><h2>꺽쇠 만들기</h2><ol><li><span style="color: rgb(215, 186, 125);">div</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">16px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">8px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">2px</span> <span style="color: rgb(206, 145, 120);">solid</span> <span style="color: rgb(206, 145, 120);">red</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-top</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-right</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">transform</span>:<span style="color: rgb(220, 220, 170);">rotate</span>(<span style="color: rgb(181, 206, 168);">-45deg</span>);</li><li>&nbsp; &nbsp; <span style="color: rgb(106, 153, 85);">/*(x,y)축을 기준으로 회전 */</span></li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">transform-origin</span>: <span style="color: rgb(181, 206, 168);">25%</span> <span style="color: rgb(181, 206, 168);">25%</span>; </li><li>&nbsp; }</li></ol><h2>화살표 만들기</h2><ol><li><span style="color: rgb(215, 186, 125);">.arrow</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">display</span>: <span style="color: rgb(206, 145, 120);">inline-block</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">position</span>: <span style="color: rgb(206, 145, 120);">relative</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">margin</span>: <span style="color: rgb(181, 206, 168);">1em</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">32px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">32px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">--color</span>: <span style="color: rgb(206, 145, 120);">#000</span>;</li><li>&nbsp; }</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.arrow::before</span>,</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.arrow::after</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">content</span>: <span style="color: rgb(206, 145, 120);">''</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">position</span>: <span style="color: rgb(206, 145, 120);">absolute</span>;</li><li>&nbsp; }</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.arrow::before</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">1px</span> <span style="color: rgb(206, 145, 120);">solid</span> <span style="color: rgb(220, 220, 170);">var</span>(<span style="color: rgb(156, 220, 254);">--color</span>);</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-right</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-bottom</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; }</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.arrow::after</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">48px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">1px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background</span>: <span style="color: rgb(220, 220, 170);">var</span>(<span style="color: rgb(156, 220, 254);">--color</span>);</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">transform-origin</span>: <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">transform</span>: <span style="color: rgb(220, 220, 170);">rotate</span>(<span style="color: rgb(181, 206, 168);">45deg</span>);</li><li>&nbsp; }</li></ol><h2>스피너 만들기</h2><ol><li><span style="color: rgb(215, 186, 125);">.spinner</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">position</span>: <span style="color: rgb(206, 145, 120);">relative</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">48px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">48px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">margin</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">color</span>: <span style="color: rgb(206, 145, 120);">transparent</span>;</li><li>}</li><li><span style="color: rgb(215, 186, 125);">.spinner::after</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">content</span>: <span style="color: rgb(206, 145, 120);">''</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">position</span>: <span style="color: rgb(206, 145, 120);">absolute</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">box-sizing</span>: <span style="color: rgb(206, 145, 120);">border-box</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">top</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">100%</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-radius</span>: <span style="color: rgb(181, 206, 168);">50%</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">8px</span> <span style="color: rgb(206, 145, 120);">solid</span> <span style="color: rgb(206, 145, 120);">silver</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-top-color</span>: <span style="color: rgb(206, 145, 120);">transparent</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">animation</span>: spin <span style="color: rgb(181, 206, 168);">1s</span> <span style="color: rgb(206, 145, 120);">linear</span> <span style="color: rgb(206, 145, 120);">infinite</span>;</li><li>}</li><li><span style="color: rgb(197, 134, 192);">@keyframes</span> <span style="color: rgb(156, 220, 254);">spin</span> {</li><li>&nbsp; to { <span style="color: rgb(156, 220, 254);">transform</span>: <span style="color: rgb(220, 220, 170);">rotate</span>(<span style="color: rgb(181, 206, 168);">360deg</span>); }</li><li>}</li></ol><h2>격자 배경 만들기</h2><ul><li>실무에서 background를 어떻게 사용할지 알 수 있다.</li></ul><ol><li><span style="color: rgb(215, 186, 125);">:root</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background</span>:</li><li>&nbsp; &nbsp; &nbsp; <span style="color: rgb(220, 220, 170);">linear-gradient</span>(to <span style="color: rgb(206, 145, 120);">bottom</span>, <span style="color: rgb(206, 145, 120);">transparent</span> <span style="color: rgb(181, 206, 168);">47px</span>, <span style="color: rgb(206, 145, 120);">silver</span> <span style="color: rgb(181, 206, 168);">47px</span>) <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">0</span> / <span style="color: rgb(181, 206, 168);">100vw</span> <span style="color: rgb(181, 206, 168);">48px</span> <span style="color: rgb(206, 145, 120);">repeat-y</span>,</li><li>&nbsp; &nbsp; &nbsp; <span style="color: rgb(220, 220, 170);">linear-gradient</span>(to <span style="color: rgb(206, 145, 120);">right</span>, <span style="color: rgb(206, 145, 120);">transparent</span> <span style="color: rgb(181, 206, 168);">47px</span>, <span style="color: rgb(206, 145, 120);">silver</span> <span style="color: rgb(181, 206, 168);">47px</span>) <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">0</span> / <span style="color: rgb(181, 206, 168);">48px</span> <span style="color: rgb(181, 206, 168);">100vh</span> <span style="color: rgb(206, 145, 120);">repeat-x</span></li><li>&nbsp; &nbsp; &nbsp; <span style="color: rgb(206, 145, 120);">black</span>;</li><li>&nbsp; }</li></ol><h2>체크 격자 배경 만들기</h2><ul><li>4개의 삼각형을 이용해서 체크무늬 패턴을 만들고 반복시킴</li></ul><ol><li><span style="color: rgb(215, 186, 125);">:root</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background-image</span>: </li><li>&nbsp; &nbsp; &nbsp; <span style="color: rgb(220, 220, 170);">linear-gradient</span>(<span style="color: rgb(181, 206, 168);">45deg</span>, <span style="color: rgb(206, 145, 120);">silver</span> <span style="color: rgb(181, 206, 168);">25%</span>, <span style="color: rgb(206, 145, 120);">transparent</span> <span style="color: rgb(181, 206, 168);">25%</span>),</li><li>&nbsp; &nbsp; &nbsp; <span style="color: rgb(220, 220, 170);">linear-gradient</span>(<span style="color: rgb(181, 206, 168);">45deg</span>, <span style="color: rgb(206, 145, 120);">transparent</span> <span style="color: rgb(181, 206, 168);">75%</span>, <span style="color: rgb(206, 145, 120);">silver</span> <span style="color: rgb(181, 206, 168);">25%</span>),</li><li>&nbsp; &nbsp; &nbsp; <span style="color: rgb(220, 220, 170);">linear-gradient</span>(<span style="color: rgb(181, 206, 168);">-45deg</span>, <span style="color: rgb(206, 145, 120);">silver</span> <span style="color: rgb(181, 206, 168);">25%</span>, <span style="color: rgb(206, 145, 120);">transparent</span> <span style="color: rgb(181, 206, 168);">25%</span>),</li><li>&nbsp; &nbsp; &nbsp; <span style="color: rgb(220, 220, 170);">linear-gradient</span>(<span style="color: rgb(181, 206, 168);">-45deg</span>, <span style="color: rgb(206, 145, 120);">transparent</span> <span style="color: rgb(181, 206, 168);">75%</span>, <span style="color: rgb(206, 145, 120);">silver</span> <span style="color: rgb(181, 206, 168);">75%</span>);</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background-size</span>: <span style="color: rgb(181, 206, 168);">20px</span> <span style="color: rgb(181, 206, 168);">20px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background-position</span>: <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">0</span>, <span style="color: rgb(181, 206, 168);">-10px</span> <span style="color: rgb(181, 206, 168);">10px</span>, <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">-10px</span>, <span style="color: rgb(181, 206, 168);">10px</span> <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; }</li></ol><h2>햄버거 아이콘 만들기</h2><ul><li>box-shadow가 핵심 </li><li>첫 번째 줄은 실제하고 나머지는 그림 </li></ul><ol><li><span style="color: rgb(215, 186, 125);">.navBtn</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">position</span>: <span style="color: rgb(206, 145, 120);">relative</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">48px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">48px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background</span>: <span style="color: rgb(206, 145, 120);">lightgray</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">color</span>: <span style="color: rgb(206, 145, 120);">transparent</span>;</li><li>&nbsp; }</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.navBtn::before</span>,</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.navBtn::after</span> { </li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">content</span>: <span style="color: rgb(206, 145, 120);">''</span>; </li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">position</span>: <span style="color: rgb(206, 145, 120);">absolute</span>;</li><li>&nbsp; }</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.navBtn::before</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">top</span>: <span style="color: rgb(181, 206, 168);">14px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">left</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">right</span>: <span style="color: rgb(181, 206, 168);">0</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">margin</span>: <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(206, 145, 120);">auto</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">24px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">4px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background</span>: <span style="color: rgb(206, 145, 120);">black</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">box-shadow</span>: <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">8px</span> <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(206, 145, 120);">black</span>, <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">16px</span> <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(206, 145, 120);">black</span>;</li><li>&nbsp; }</li><li>&nbsp; <span style="color: rgb(215, 186, 125);">.navBtn::after</span> {</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">top</span>: <span style="color: rgb(181, 206, 168);">10px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">right</span>: <span style="color: rgb(181, 206, 168);">8px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">width</span>: <span style="color: rgb(181, 206, 168);">8px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">height</span>: <span style="color: rgb(181, 206, 168);">8px</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">border-radius</span>: <span style="color: rgb(181, 206, 168);">50%</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">box-shadow</span>: <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">0</span> <span style="color: rgb(181, 206, 168);">3px</span> <span style="color: rgb(206, 145, 120);">white</span>;</li><li>&nbsp; &nbsp; <span style="color: rgb(156, 220, 254);">background</span>: <span style="color: rgb(206, 145, 120);">red</span>;</li><li>&nbsp; }</li></ol><h2>선택 콘트롤 만들기</h2><ul><li>https://codepen.io/jlkim909/pen/WNgjbGq</li></ul>`
export const cssOptimization='<h1>퍼포먼스 항샹시키기</h1><p><strong>성능 최적화를 위한 구글 Lighthouse 크롬 도구</strong></p><ul><li>css최적화에 관한 기법과 오류들이 보고가 된다.</li><li>2KB 이상 미사용 css가 포함된 파일을 검출</li></ul><h2>요약</h2><p><strong>css코드 최적화 하는 방법</strong></p><ul><li>웹 브라우저는 외부 JS, CSS 파일을 로딩 하고 파싱 하는 동안 렌더링 차단 상태를 유지한다.</li><li>사용하지 않은 JS, CSS를 제거한다.</li><li>필수 코드에 해당하는 &lt;style&gt;, &lt;script&gt;는 페이지에 임베딩하기</li><li>필수 아닌 JS는 &lt;/body&gt; 종료 직전 위치를 고려. defer, async 속성을 사용</li><li>필수 아닌 CSS는 병렬 로딩(preload)하고 지연 적용(onload)하기</li></ul><p><strong>LCP 성능 개선하기(덩어리 콘텐츠 빨리 그리는 방법)</strong></p><ul><li>LCP는 뷰포트에 표시하는 가장 큰 콘텐츠 렌더링 성능</li><li>가장 큰 덩어리 콘텐츠를 2.5초 이내로 표시해야 한다.</li><li>JS/CSS 라이브러리 의존도를 낮추어야 한다.</li><li>preconnect/preload 속성으로 외부 자원 최적화</li><li>photo 요소의 type, media 속성으로 이미지 전송량 최적화</li><li>loading/decoding 속성으로 이미지 렌더링 최적화</li></ul><p><strong>CLS 성능 개선하기(덜컥덜컥 누적 배치 변경 문제)</strong></p><ul><li>이미지/영상 요소에 비율 힌트(width, height) 제공</li><li>추가 DOM에 자리표시자 제공</li><li>웹 폰트와 유사한 시스템 대체 글꼴 제공</li></ul><p><br></p><h1><strong class="ql-size-large" style="background-color: rgb(204, 232, 204);">CSS코드 최적화(css optimization)</strong></h1><h2>Remove unused CSS(사용하지 않는 css 제거)</h2><ul><li>css는 페이지 렌더링을 차단하는 리소스.</li><li>브라우저가 스타일을 계산하는데 잠재적으로 더 많은 시간을 소비</li><li>Render blocking을 가중하는 요인이 됨</li></ul><h2>Eliminate render-blocking resources(렌더 차단 리소스 제거)</h2><ul><li>문제가 되는 이유 : 브라우저가 외부 리소스를 다운로드하고 파싱하는 동안 페이지 콘텐츠를 파싱하거나 렌더링하지 않기 때문에 페이지 속도 저하의 원인</li><li>렌더 블로킹 리소스 표시 조건</li><li>[1] defer, async 속성이 없는 &lt;head&gt; 요소의 &lt;script&gt; 태그</li><li>--&gt; script 태그에 defer 속성을 사용하면 HTML 파싱 중단 없이 계속 진행하게 되어 HTML은 빠르게 파싱이 되고 화면에 빠르게 그림</li><li>[2] media 속성과 값이 없는 &lt;link rel="stylesheet"&gt; 태그</li></ul><p><strong>Render blocking &lt;script&gt;</strong></p><ul><li>async : 병렬 다운로드, 즉시 실행</li><li>defer : 병렬 다운로드, 지연 실행</li><li>필수 스크립트는 html &lt;script&gt; 형식으로 작성(embedded 형식)</li><li>기타 스트립트는 &lt;/body&gt; 종료 태그 직전에 선언</li><li>마지막에 파싱해도 문제 없으면 defer 속성</li><li>가능한 빠른 시점에 실행 필요하면 async 속성</li></ul><p><strong>css의 Render-blocking resources를 제거하는 방법</strong></p><ul><li>Render blocking &lt;link rel="stylesheet"&gt;</li><li>media 속성이 없거나 값이 all이면 렌더 차단 리소스</li><li>모바일은 모바일 코드만 ,데스크탑 코드는 데스크탑 코드만 다운로드해서 렌더링하도록 개발하면 가장 좋은 결과를 얻을 수 있다.</li></ul><p><strong>방법</strong></p><ul><li>반응형 웹인 경우 해상도 구간별로 CSS파일을 분리하고 media 속성으로 분기</li><li>Ex)</li></ul><ol><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">link</span> <span style="color: rgb(156, 220, 254);">href</span>=<span style="color: rgb(206, 145, 120);">"*.css"</span> <span style="color: rgb(156, 220, 254);">rel</span>=<span style="color: rgb(206, 145, 120);">"stylesheet"</span> <span style="color: rgb(156, 220, 254);">media</span>=<span style="color: rgb(206, 145, 120);">"(max-width:639px)"</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">link</span> <span style="color: rgb(156, 220, 254);">href</span>=<span style="color: rgb(206, 145, 120);">"*.css"</span> <span style="color: rgb(156, 220, 254);">rel</span>=<span style="color: rgb(206, 145, 120);">"stylesheet"</span> <span style="color: rgb(156, 220, 254);">media</span>=<span style="color: rgb(206, 145, 120);">"(max-width:640px) and (max-width:960px)"</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">link</span> <span style="color: rgb(156, 220, 254);">href</span>=<span style="color: rgb(206, 145, 120);">"*.css"</span> <span style="color: rgb(156, 220, 254);">rel</span>=<span style="color: rgb(206, 145, 120);">"stylesheet"</span> <span style="color: rgb(156, 220, 254);">media</span>=<span style="color: rgb(206, 145, 120);">"(max-width:961px)"</span><span style="color: rgb(128, 128, 128);">&gt;</span></li></ol><ul><li>필수 스타일 페이지 &lt;head&gt;에 &lt;style&gt; 형식으로 작성</li><li>지연 스타일은 &lt;link rel="preload"&gt; 속성으로 병렬 로딩 후 지연 적용.</li><li>Ex) 필수 스타일 임베딩, 지연 스타일 병렬 로딩 후 지연 적용.</li></ul><ol><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">style</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li>&nbsp;&nbsp;&nbsp;<span style="color: rgb(106, 153, 85);">/* 필수 스타일 여기 */</span></li><li><span style="color: rgb(128, 128, 128);">&lt;/</span><span style="color: rgb(86, 156, 214);">style</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">link</span> <span style="color: rgb(156, 220, 254);">rel</span>=<span style="color: rgb(206, 145, 120);">"preload"</span> <span style="color: rgb(156, 220, 254);">as</span>=<span style="color: rgb(206, 145, 120);">"style"</span> <span style="color: rgb(156, 220, 254);">href</span>=<span style="color: rgb(206, 145, 120);">"x.css"</span> <span style="color: rgb(156, 220, 254);">onload</span>=<span style="color: rgb(206, 145, 120);">"</span><span style="color: rgb(86, 156, 214);">this</span><span style="color: rgb(206, 145, 120);">.</span><span style="color: rgb(220, 220, 170);">onload</span><span style="color: rgb(206, 145, 120);">(</span><span style="color: rgb(86, 156, 214);">null</span><span style="color: rgb(206, 145, 120);">);</span><span style="color: rgb(86, 156, 214);">this</span><span style="color: rgb(206, 145, 120);">.</span><span style="color: rgb(156, 220, 254);">rel</span>=<span style="color: rgb(206, 145, 120);">"</span><span style="color: rgb(156, 220, 254);">stylesheet</span><span style="color: rgb(244, 71, 71);">""</span></li></ol><ul><li>this.onload=null 할당 이유: rel속성을 변경할 때 일부 브라우저가 다시 onload 실행하는 것을 방어</li></ul><p>실습 과제</p><ul><li>https://github.com/naradesign/css 저장소 포크</li><li>defer-css.css 파일에서 Unused CSS 코드를 찾아 제거</li><li>defer-css-unoptimized.html 파일에서 필수 CSS 코드를 &lt;head&gt; 내부에 추가</li><li>defer-css-unoptimizied.html 파일에서 렌더 블로킹 CSS를 병렬로딩(preload)하고 지연 적용(onload)하기</li></ul><p><br></p><h1><span class="ql-size-large" style="background-color: rgb(204, 232, 204);">덩어리 콘텐츠 빨리 그리기</span></h1><p><strong>LCP : 구글의 핵심 성능 지표에 포함되는 한 가지 항목</strong></p><ul><li>웹 페이지 뷰 포트 안에서 가장 큰 덩어리 콘텐츠 하나를 그리는 것은 단순히 이미지 한 장을 빨리 로딩시키는 것의 문제가 아니라 그 이미지 한 장을 로딩하기까지 모든 과정의 문제를 성능 문제를 해결해야만 이 LCP가 좋아지기 때문(성능에 관한 모든 지식을 총동원해서 이 부분에 집약해서 적용해야만 LCP문제를 해결할 수 있다.css 최적화, 이미지 최적화 등)</li><li>구글 검색결과 순위에 반영 된다.</li><li>LCP를 2.5초 이내로 로딩시켜야만 좋은 사용자경험을 줄 수 있다.</li></ul><p>이미지가 늦게 로딩되는 이유</p><ul><li>대부분의 LCP는 이미지일 확률이 높다(hero image라 부름)</li><li>이미지가 무겁기 때문만은 아님</li><li>이미지를 그리기 전에 나타나는 모든 과정들의 성능을 개선해야만 LCP 성능을 개선할 수 있음.</li></ul><h2>LCP 성능 개선하기</h2><p><strong>라이브러리 의존 줄이기(jquery, lodash, normalize ...)</strong></p><ul><li>사용하려는 기능 외에 더 많은 기능들을 포함하고 있기 때문에 렌더 차단 리소스로 작용할 확률이 높다.</li><li><strong>https://youmightnotneed.com/ : </strong>의존하고 있던 jQuery나 Lodash 대신 사용할 수 있는 바닐라 스크립트를 찾아 볼 수 있다.</li></ul><p><strong>사용하지 않는 CSS 제거하기</strong></p><p><strong>Preconnect / Preload 기법</strong></p><ul><li>CSS를 로딩하고 해석하는 동안 웹 페이지의 렌더링이 차단 되기 때문에 해결하도록 해야 한다.</li><li>preconnect : href에 적힌 URL을 미리 연결하는 기능</li><li>preload : preload 속성을 적용하면 CSS파일은 다운로드를 하면서 웹 페이지 렌더링을 차단하지 않고, 웹 페이지 렌더링을 하는 동시에 CSS 파일을 다운로드 하게 된다. 그리고 onload 스크립트를 이용해서 CSS다운로딩이 끝나면 preload 값을 stylesheet로 바꿔 주어 웹 페이지에 적용하게 된다.(지연 적용)</li></ul><p>&lt;link rel="preconnect"&gt;</p><ul><li>도메인을 알지만 자원의 최종 경로를 모르는 경우 서버와의 연결을 미리 설정</li><li>DNS(Domain Name Server), TCP(Transmission Control Protocol), TLS(Transfer Layer Security) 왕복에 필요한 시간을 단축</li><li>서드 파티 자원 연결에 적합</li></ul><p>&lt;link rel="preload"&gt;</p><ul><li>필요한 자원을 병렬 다운로드</li><li>자원을 로딩하는 동안 렌더링을 차단하지 않음</li><li>as 속성을 함께 명시해 주어야 한다. (ex) as="style", as="script", as="image"</li></ul><p><strong>히어로 이미지 preload</strong></p><ul><li>원래 image는 HTML body 요소 안쪽에 마크업이 되어 있는데, 첫 번째 hero image를 빠르게 로딩하기 위해 HTML head에서 미리 로딩을 하는 방법</li><li>Ex)</li></ul><ol><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">head</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li>&nbsp;&nbsp;<span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">link</span> <span style="color: rgb(156, 220, 254);">rel</span>=<span style="color: rgb(206, 145, 120);">"preload"</span> <span style="color: rgb(156, 220, 254);">as</span>=<span style="color: rgb(206, 145, 120);">"image"</span> <span style="color: rgb(156, 220, 254);">media</span>=<span style="color: rgb(206, 145, 120);">"(max-width:640px)"</span> <span style="color: rgb(156, 220, 254);">href</span>=<span style="color: rgb(206, 145, 120);">"small.avif"</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li>&nbsp;&nbsp;<span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">link</span> <span style="color: rgb(156, 220, 254);">rel</span>=<span style="color: rgb(206, 145, 120);">"preload"</span> <span style="color: rgb(156, 220, 254);">as</span>=<span style="color: rgb(206, 145, 120);">"image"</span> <span style="color: rgb(156, 220, 254);">media</span>=<span style="color: rgb(206, 145, 120);">"(max-width:641px)"</span> <span style="color: rgb(156, 220, 254);">href</span>=<span style="color: rgb(206, 145, 120);">"large.avif"</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li>&nbsp;<span style="color: rgb(128, 128, 128);">&lt;/</span><span style="color: rgb(86, 156, 214);">head</span><span style="color: rgb(128, 128, 128);">&gt;</span></li></ol><p><strong>Feature detection</strong></p><ul><li>image type 이나 Viewport width를 감지해서 성능을 개선하는 방법</li><li>&lt;img src={image} alt&gt; 이런식으로 사용하지 않고, picture 태그를 이용해서 사용</li><li>Ex)</li></ul><ol><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">picture</span><span style="color: rgb(128, 128, 128);">&gt;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(86, 156, 214);">{</span><span style="color: rgb(106, 153, 85);">/* avif 파일이 적용 가능, width가 640px보다 작을 때&nbsp;*/</span><span style="color: rgb(86, 156, 214);">}</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">source</span> <span style="color: rgb(156, 220, 254);">srcSet</span>=<span style="color: rgb(206, 145, 120);">"small.avif"</span> <span style="color: rgb(156, 220, 254);">type</span>=<span style="color: rgb(206, 145, 120);">"image/avif"</span> <span style="color: rgb(156, 220, 254);">media</span>=<span style="color: rgb(206, 145, 120);">"(max-width:640px)"</span><span style="color: rgb(128, 128, 128);">/&gt;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">source</span> <span style="color: rgb(156, 220, 254);">srcSet</span>=<span style="color: rgb(206, 145, 120);">"large.avif"</span> <span style="color: rgb(156, 220, 254);">type</span>=<span style="color: rgb(206, 145, 120);">"image/avif"</span><span style="color: rgb(128, 128, 128);">/&gt;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(86, 156, 214);">{</span><span style="color: rgb(106, 153, 85);">/* avif 파일 적용 불가, webp 적용 가능 */</span><span style="color: rgb(86, 156, 214);">}</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">source</span> <span style="color: rgb(156, 220, 254);">srcSet</span>=<span style="color: rgb(206, 145, 120);">"small.webp"</span> <span style="color: rgb(156, 220, 254);">type</span>=<span style="color: rgb(206, 145, 120);">"image/webp"</span> <span style="color: rgb(156, 220, 254);">media</span>=<span style="color: rgb(206, 145, 120);">"(max-width:640px)"</span><span style="color: rgb(128, 128, 128);">/&gt;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">source</span> <span style="color: rgb(156, 220, 254);">srcSet</span>=<span style="color: rgb(206, 145, 120);">"small.webp"</span> <span style="color: rgb(156, 220, 254);">type</span>=<span style="color: rgb(206, 145, 120);">"image/webp"</span><span style="color: rgb(128, 128, 128);">/&gt;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(86, 156, 214);">{</span><span style="color: rgb(106, 153, 85);">/* 모두 적용 불가 일 때 */</span><span style="color: rgb(86, 156, 214);">}</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">img</span> <span style="color: rgb(156, 220, 254);">src</span>=<span style="color: rgb(206, 145, 120);">"small.jpg"</span> <span style="color: rgb(156, 220, 254);">alt</span>=<span style="color: rgb(206, 145, 120);">"smallJPG"</span><span style="color: rgb(128, 128, 128);">/&gt;</span></li><li><span style="color: rgb(128, 128, 128);">&lt;/</span><span style="color: rgb(86, 156, 214);">picture</span><span style="color: rgb(128, 128, 128);">&gt;</span></li></ol><p><strong>Image Loading / Decoding</strong></p><ul><li>&lt;img&gt; 태그를 사용할 때, loading, decoding 속성을 명시</li></ul><ol><li><span style="color: rgb(128, 128, 128);">&lt;</span><span style="color: rgb(86, 156, 214);">img</span> <span style="color: rgb(156, 220, 254);">src</span>=<span style="color: rgb(206, 145, 120);">"example.jpg"</span> <span style="color: rgb(156, 220, 254);">loading</span>=<span style="color: rgb(206, 145, 120);">"lazy"</span> <span style="color: rgb(156, 220, 254);">decoding</span>=<span style="color: rgb(206, 145, 120);">"async"</span> <span style="color: rgb(128, 128, 128);">/&gt;</span></li></ol><ul><li>loading="lazey" 속성 : 이미지는 웹 페이지에서 표시 될 때 뷰 포트 안에 들어와 있지 않으면 로딩하지 않음. 대략 뷰포트 높이의 1~2배 지점까지 근접하면 로딩</li><li>decoding="async" 속성 : decoding은 암호화했던 이미지를 복호화하는 방법인데, 복호화하는 방법으로 async라는 값을 제공하면 화면에 다른 요소를 렌더링하는 걸 중단하지 않고 다른 요소를 먼저 표시하고 이미지를 뒤늦게 화면에 표시하는 게 가능한 기법(지연 표시). 디코딩을 지연시켜 다른 콘텐츠의 표시 속도가 빨라짐</li><li>img 요소에만 사용하면 된다.</li></ul><p>실습과제</p><ul><li>https://github.com/naradesign/lcp 저장소 포크</li><li>index.html 파일의 LCP를 개선</li></ul><p><br></p><h1><span style="background-color: rgb(204, 232, 204);">덜컥덜컥 누적 배치 변경 문제</span></h1><p>CLS(Cumulative Layout Shift) : 사용자 경험을 측정하는 대표적인 지표</p><ul><li>구글의 검색 결과에 반영</li><li>목표는 0.1 이내로 단축하는 것</li><li>좋지 않다면 사용자가 정확한 위치에 포인팅하기 어려운 상황을 연출</li><li>점수 계산법 : 충격 비율 x 이동 비율 = CLS 점수</li><li>CLS 확인 : 개발자 도구 -&gt; performance -&gt; experience -&gt; summary</li></ul><h2>CLS 발생 사례</h2><p><strong>첫 페인팅 이후 뷰포트 안에서 배치가 바뀌는 상황</strong></p><ul><li>치수를 알 수 없는 이미지 로딩</li><li>동적으로 추가된 DOM</li><li>웹 폰트 swap 페인팅</li></ul><p><strong>이미지, 배너</strong></p><ul><li>페이지 상단에 가장 큰 덩어리 배너가 로딩이 되면서 페이지 전체가 아래쪽으로 밀려 나는 상황(실수로 배너를 누르게 된다.)</li></ul><p><strong>FOIT/FOUT</strong></p><ul><li>FOIT(Font of Invisible Text) :텍스트가 보이지 않다가 갑자기 화면에 나타나는 것</li><li>FOUT(Font of Unstyled Text) : 스타일되지 않은 글꼴이 표시되었다가 갑자기 웹 폰트 글꼴이 뒤늦게 로딩 되면서 시스템 글꼴이 대체해서 웹 폰트로 바뀌는 상황 )</li><li>글꼴마다 줄 간격이 다르기 때문에 페이지 콘텐츠가 전체적으로 흔들리는 상황을 발생시키게 된다.</li></ul><h2><strong>CLS 문제 해결</strong></h2><ul><li>동적으로 추가하는 콘텐츠에 자리표시자를 제공(스켈레톤 UI 같이)</li><li>이미지/영상 요소에 비율 힌트 제공(비율을 설정)</li><li>애니메이션 적용 시 transform 사용(width x, height x)</li><li>영상 종횡비 유지하기(padding)</li></ul><p><strong>이미지/영상 비율 힌트 제공하는 방법</strong></p><ul><li>&lt;img&gt; 태그에 width, height 속성 넣기(css로 맞추더라도 넣도록 하자)</li></ul><p class="ql-align-center"><span style="background-color: rgb(204, 232, 204);">-&gt; 중요한건 실제 width, height 값이 아닌, 비율을 맞추는 점이다.</span></p><ul><li>aspect-ratio 사용</li></ul><p><strong>자리 표시자 제공 방법</strong></p><ol><li><span style="color: rgb(215, 186, 125);">.heroBanner</span>{</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">min-height</span>:<span style="color: rgb(181, 206, 168);">100px</span>;</li><li>&nbsp; <span style="color: rgb(156, 220, 254);">background</span>:<span style="color: rgb(206, 145, 120);">silver</span>;</li><li>}</li></ol><ul><li>최소값을 미리 집어넣고, 배경색으로 표시</li></ul><p><strong>웹 폰트 대체 글꼴(줄간격, 행간격 등 특성이 비슷한 대체 글꼴 찾기)</strong></p><ol><li><span style="color: rgb(106, 153, 85);">/* 원하는 글꼴과 sans-serif 맞지 않음 (x)*/</span></li><li>&nbsp; <span style="color: rgb(156, 220, 254);">font-family</span>: <span style="color: rgb(206, 145, 120);">"원하는 글꼴"</span>, <span style="color: rgb(206, 145, 120);">sans-serif</span>;</li><li>&nbsp; <span style="color: rgb(106, 153, 85);">/* 원하는 글꼴과 Verdana의 특성이 맞음 (o)*/</span></li><li>&nbsp; <span style="color: rgb(156, 220, 254);">font-family</span>: <span style="color: rgb(206, 145, 120);">"원하는 글꼴"</span>, <span style="color: rgb(206, 145, 120);">Verdana</span>, <span style="color: rgb(206, 145, 120);">sans-serif</span>;</li></ol><p><br></p>'